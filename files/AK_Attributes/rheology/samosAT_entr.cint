double tau0 = 0.0;
double mue = 0.155;
double Rs0 = 0.222;
double kappa = 0.43;
double R = 0.1;
double B = 4.13;



void get_par(
	char s[])
{
	sprintf(s, "tau0=%g mue=%g Rs0=%g kappa=%g R=%g B=%g", tau0, mue, Rs0, kappa, R, B);
}

void set_par(
	char s[])
{
	double Rs0 = 1.0;
	double Nl0 = 100.0;
	double cdyn = 0.0417;
	double Nlk = 3.7;
	if(sscanf(s, "tau0=%lf mue=%lf Rs0=%lf kappa=%lf R=%lf B=%lf", tau0, mue, Rs0, kappa, R, B) != 6){
		sscanf(s, "mue=%lf Rs0=%lf Nl0=%lf cdyn=%lf Nlk=%lf", mue, Rs0, Nl0, cdyn, Nlk);
		Rs0 *= 200.0/900.0;
		tau0 = 9.0 * Nl0 * mue;
		kappa = 30.0 / sqrt(200.0 / cdyn);
		B = 4.13;
		R = 0.9 * Nlk * exp(kappa * B) / 200.0;
	}
}



// return local bottom shear stress [N/m2]
double tau(
	double p,     // local bottom pressure [Pa], including centrifugal forces
	double v,     // local velocity magnitude
	double h,     // local flow depth [m]
	double d,     // flow density [kg/m3]
	double t,     // current time [s]
	double x[3],  // local position vector [m,m,m]
	double n[3])  // local normalized surface normal vector
{
	double Rs = d * v * v / (p+0.001);
	double div = h / R;
	if(div < 1.0) div = 1.0;
	div = log(div) / kappa + B;
// debug output: print goes to shell
//print x, n;
	return tau0 + p * mue * (1.0 + Rs0/(Rs0+Rs)) + d * v * v / (div * div);
}



// return entrainment energy loss per entrained area [J/m2]
double entrainment_energy_loss(
	double p,           // arguments as above in tau()
	double v,
	double h,
	double d,
	double t,
	double x[3],
	double n[3],
	double tau_b,       // bottom shear stress [N/m2] (as computed by tau())
	double area_weight, // entrainment area weight = entrained mass / entrainment-area [kg/m2]
	double shearRes,    // entrainment shear resistance value (as entered in GUI) [J/m2]
	double dfrmtRes)    // entrainment deformation resistance value (as entered in GUI) [J/kg]
{
	// just a test: should give same loss as without function
//print x, n, tau_b, area_weight, shearRes, dfrmtRes;
	return shearRes + dfrmtRes * area_weight;
}

